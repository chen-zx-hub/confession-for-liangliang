<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', sans-serif; color: white; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* ç»ç’ƒæ‹Ÿæ€ UI é¢æ¿ */
        #ui-container {
            position: absolute; top: 20px; right: 20px; width: 260px;
            background: rgba(20, 20, 25, 0.75); backdrop-filter: blur(12px);
            padding: 25px; border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10; transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.6s ease;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        
        /* éšè— UI æ—¶çš„æ ·å¼ */
        .ui-hidden {
            transform: translateX(120%); /* å‘å³æ»‘å‡ºå±å¹• */
            opacity: 0;
            pointer-events: none;
        }

        /* é€€å‡ºå…¨å±æŒ‰é’® (é»˜è®¤éšè—) */
        #exit-fullscreen-btn {
            position: absolute; top: 20px; left: 20px;
            padding: 10px 20px; background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3); border-radius: 30px;
            color: white; cursor: pointer; z-index: 20;
            display: none; backdrop-filter: blur(5px);
            transition: background 0.3s;
            font-size: 14px;
        }
        #exit-fullscreen-btn:hover { background: rgba(255,255,255,0.3); }

        h3 { margin-top: 0; text-align: center; color: #ffd700; letter-spacing: 2px; font-weight: 300; }
        
        .btn-group { display: flex; flex-direction: column; gap: 12px; margin-top: 20px; }
        
        button {
            width: 100%; padding: 12px;
            border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        #camera-btn { background: linear-gradient(135deg, #ff6b6b, #c0392b); box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3); }
        #camera-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4); }
        
        #fullscreen-btn { background: linear-gradient(135deg, #4facfe, #00f2fe); box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3); color: #003; }
        #fullscreen-btn:hover { transform: translateY(-2px); }

        /* æ‘„åƒå¤´é¢„è§ˆå°çª— */
        #video-preview {
            position: absolute; bottom: 20px; left: 20px; width: 140px; height: 105px;
            border-radius: 12px; border: 2px solid rgba(255,255,255,0.1); z-index: 5;
            object-fit: cover; transform: scaleX(-1); opacity: 0; transition: opacity 0.5s;
            background: #000;
        }
        #video-preview.active { opacity: 0.8; border-color: #00ff88; }

        .status-text { font-size: 13px; color: #aaa; text-align: center; line-height: 1.6; margin-bottom: 10px; }
        .highlight { color: #fff; font-weight: bold; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #888; z-index: 0; font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="loading">èµ„æºåŠ è½½ä¸­...</div>
    <div id="canvas-container"></div>
    <video id="video-preview" playsinline></video>
    <button id="exit-fullscreen-btn">âœ• é€€å‡ºæ²‰æµ¸æ¨¡å¼</button>

    <div id="ui-container">
        <h3>âœ¨ MERRY CHRISTMAS âœ¨</h3>
        
        <div class="status-text">
            ç›®å‰çŠ¶æ€: <span id="status-label" class="highlight" style="color:#ff4444">æœªè¿æ¥</span>
            <br>
            <span style="font-size:12px; opacity:0.7">æåˆæ‰‹æŒ‡ç¼©æ”¾ â€¢ å¼ å¼€æ‰‹æŒ‡æ”¾å¤§</span>
        </div>

        <div class="btn-group">
            <button id="camera-btn">ğŸ“· å¯åŠ¨äº¤äº’</button>
            <button id="fullscreen-btn">ğŸ“º å…¨å±æ²‰æµ¸</button>
        </div>
    </div>

    <!-- 1. ä¸¥æ ¼ä½¿ç”¨ä½  Version4 ç‰ˆæœ¬éªŒè¯è¿‡çš„åº“åœ°å€ (unpkg) -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- æ ¸å¿ƒä¿®å¤ï¼šä»£ç ç”Ÿæˆçº¹ç†ï¼Œæœç»å›¾ç‰‡åŠ è½½æŠ¥é”™ ---
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        let scene, camera, renderer, particles, material;
        const particleCount = 28000; // å¢åŠ æ•°é‡ä»¥æ”¯æŒå¤æ‚é€ å‹
        let handScale = 1.0; 
        let time = 0;

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.002); // é…åˆèƒŒæ™¯è‰²

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;
            camera.position.y = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // --- ç²’å­ç³»ç»Ÿæ„å»º ---
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b, size;
                
                // è¿›åº¦ 0-1
                const p = i / particleCount;

                if (i < particleCount * 0.05) {
                    // Part 1: é¡¶ç«¯äº”è§’æ˜Ÿ (Bright Star)
                    // ä½¿ç”¨çƒåæ ‡éšæœºç”Ÿæˆï¼Œç„¶åå‹æ‰ä¸€ç‚¹
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const rad = 2.5 * Math.random(); 
                    
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = 18 + rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                    
                    r=1; g=1; b=1; // çº¯ç™½é«˜äº®
                    size = 1.2;
                } 
                else if (i < particleCount * 0.15) {
                    // Part 2: ç¯å¢ƒæ˜Ÿå…‰ (Surrounding Stars)
                    // åœ¨æ ‘å‘¨å›´çš„å¤§èŒƒå›´å†…éšæœºåˆ†å¸ƒ
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 20 + Math.random() * 30; // è¿œç¦»ä¸­å¿ƒ
                    const height = (Math.random() - 0.5) * 60;
                    
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                    y = height;

                    r=0.6; g=0.8; b=1; // æ·¡è“è‰²æ˜Ÿå…‰
                    size = Math.random() * 0.8;
                }
                else {
                    // Part 3: ä¸»ä½“åœ£è¯æ ‘ (Layered Tree)
                    const h = Math.random(); // 0(åº•) -> 1(é¡¶)
                    
                    // æ ¸å¿ƒç®—æ³•ï¼šåˆ†å±‚æ•ˆæœ
                    // åŸºç¡€åœ†é”¥ + æ­£å¼¦æ³¢æ‰°åŠ¨
                    const layers = 6; // 6å±‚æ ‘å¶
                    const layerEffect = Math.sin(h * Math.PI * layers); // æ³¢æµª
                    const baseRadius = 14 * (1 - h) + 0.5;
                    
                    // è®©æ³¢æµªå‘å¤–å‡¸èµ·
                    const finalRadius = baseRadius * (0.8 + 0.2 * layerEffect * layerEffect);
                    
                    // å¢åŠ è“¬æ¾åº¦
                    const spread = Math.random(); 
                    const rFinal = finalRadius * Math.sqrt(spread); 
                    
                    const angle = h * 50 + Math.random() * Math.PI * 2;
                    
                    x = rFinal * Math.cos(angle);
                    z = rFinal * Math.sin(angle);
                    y = -14 + h * 30; // æ ‘é«˜èŒƒå›´

                    // é¢œè‰²ï¼šæ¢¦å¹»ç²‰é‡‘
                    // å†…éƒ¨åé‡‘ï¼Œå¤–éƒ¨åç²‰
                    const mix = Math.random();
                    if (mix > 0.8) {
                        r=1; g=1; b=1; // é—ªç‰‡
                        size = 1.0;
                    } else if (spread > 0.8) {
                        r=1; g=0.4; b=0.6; // è¾¹ç¼˜ç²‰
                        size = 0.6;
                    } else {
                        r=1; g=0.9; b=0.5; // å†…éƒ¨é‡‘
                        size = 0.5;
                    }
                }

                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
                
                colors[i*3] = r;
                colors[i*3+1] = g;
                colors[i*3+2] = b;
                
                sizes[i] = size;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            // è‡ªå®šä¹‰å°ºå¯¸å±æ€§ï¼ˆéœ€è¦Shaderæˆ–ç®€å•å¤„ç†ï¼Œè¿™é‡Œç”¨Materialçš„ç»Ÿä¸€sizeé…åˆé€æ˜åº¦æ¨¡æ‹Ÿï¼‰

            material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                map: createStarTexture(),
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            document.getElementById('loading').style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;
            
            if(particles) {
                // æ•´ä½“æ—‹è½¬
                particles.rotation.y = time * 0.2;
                
                // ç®€å•çš„å‘¼å¸æµ®åŠ¨
                particles.position.y = Math.sin(time) * 0.5;
                
                // æ‰‹åŠ¿ç¼©æ”¾å¹³æ»‘å¤„ç†
                const currentScale = particles.scale.x;
                const smoothScale = currentScale + (handScale - currentScale) * 0.1;
                particles.scale.set(smoothScale, smoothScale, smoothScale);
            }

            renderer.render(scene, camera);
        }

        // --- äº¤äº’é€»è¾‘ ---
        
        // å…¨å±å¤„ç†
        function toggleFullscreen() {
            const ui = document.getElementById('ui-container');
            const exitBtn = document.getElementById('exit-fullscreen-btn');
            
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert("å…¨å±è¢«æ‹¦æˆª: " + err.message);
                });
            } else {
                document.exitFullscreen();
            }
        }

        document.addEventListener('fullscreenchange', () => {
            const ui = document.getElementById('ui-container');
            const exitBtn = document.getElementById('exit-fullscreen-btn');
            
            if (document.fullscreenElement) {
                ui.classList.add('ui-hidden'); // æ»‘å‡ºéšè—
                exitBtn.style.display = 'block';
            } else {
                ui.classList.remove('ui-hidden'); // æ»‘å…¥æ˜¾ç¤º
                exitBtn.style.display = 'none';
            }
        });

        // æ‘„åƒå¤´å¤„ç† (ä¸¥æ ¼å¤ç”¨ Version4 é€»è¾‘)
        async function startCamera() {
            const btn = document.getElementById('camera-btn');
            const label = document.getElementById('status-label');
            const preview = document.getElementById('video-preview');
            
            btn.innerText = "â³ å¯åŠ¨ä¸­...";
            btn.disabled = true;

            try {
                // æ£€æŸ¥åº“
                if (typeof Hands === 'undefined') throw new Error("ç»„ä»¶æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ");

                const hands = new Hands({locateFile: (file) => {
                    return `https://unpkg.com/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        label.innerText = "ğŸ– å·²æ•æ‰æ‰‹åŠ¿";
                        label.style.color = "#00ff88";
                        
                        const lm = results.multiHandLandmarks[0];
                        // æ‹‡æŒ‡ tip(4) - é£ŸæŒ‡ tip(8)
                        const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        
                        // æ˜ å°„ç®—æ³•ï¼šè·ç¦» 0.02~0.3 -> ç¼©æ”¾ 0.5~2.5
                        const target = Math.max(0.5, Math.min(2.5, (dist - 0.02) * 7 + 0.5));
                        handScale = target;
                    } else {
                        label.innerText = "ğŸ” å¯»æ‰¾æ‰‹åŠ¿...";
                        label.style.color = "#ffaa00";
                    }
                });

                const cameraUtils = new Camera(preview, {
                    onFrame: async () => { await hands.send({image: preview}); },
                    width: 320, height: 240
                });

                await cameraUtils.start();
                
                btn.innerText = "âœ… è¿è¡Œä¸­";
                preview.classList.add('active'); // æ˜¾ç¤ºé¢„è§ˆæ¡†

            } catch (err) {
                console.error(err);
                alert("å¯åŠ¨å¤±è´¥: " + err.message);
                btn.innerText = "âŒ å¤±è´¥ (é‡è¯•)";
                btn.disabled = false;
            }
        }

        // --- åˆå§‹åŒ– ---
        window.onload = function() {
            try {
                initThree();
                animate();

                // ç»‘å®šæŒ‰é’®
                document.getElementById('camera-btn').addEventListener('click', startCamera);
                document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
                document.getElementById('exit-fullscreen-btn').addEventListener('click', toggleFullscreen);

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

            } catch(e) {
                console.log(e);
            }
        };
    </script>
</body>
</html>