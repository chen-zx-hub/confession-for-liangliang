<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transition: transform 0.3s ease;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #aaa;
        }
        select, input[type="color"] {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #222;
            color: white;
            outline: none;
        }
        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #ff00cc, #3333ff);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        button:hover {
            opacity: 0.9;
        }
        #video-preview {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            background: #000;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            z-index: 20;
            pointer-events: none;
            text-align: center;
            line-height: 1.5;
        }
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #ff3333;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-active {
            background-color: #33ff33;
        }
        #gesture-info {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
            text-align: center;
        }

        #heart-date {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: #fff8e7; /* æš–ç±³è‰² */
            text-shadow: 0 0 15px #ff8c00, 0 0 30px #ff4500; /* æš–æ©™è‰²å…‰æ™• */
            z-index: 4;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            font-family: 'Segoe UI', cursive;
            letter-spacing: 5px;
            font-weight: bold;
        }

        #fireworks-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            color: #ff00ff; /* éœ“è™¹ç²‰ */
            text-shadow: 0 0 20px #ff00ff, 0 0 40px #00ffff;
            z-index: 4;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 900;
        }
    </style>
</head>
<body>

    <div id="loading">æ­£åœ¨è¿æ¥å›½å†…é•œåƒæº...<br><span style="font-size:14px; opacity:0.7">ç¬¬ä¸€æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</span></div>
    
    <div id="heart-date">2024.10.1</div>
    <div id="fireworks-text">520</div>
    <div id="canvas-container"></div>
    
    <video id="video-preview" playsinline></video>

    <div id="ui-container">
        <h3 style="margin-top:0; text-align:center;">ğŸ„ åœ£è¯èŠ‚å’¯</h3>
        
        <div class="control-group">
            <label>é€‰æ‹©æ¨¡å‹</label>
            <select id="shape-select">
                <option value="heart">â¤ï¸ é™ˆå°æ˜•</option>
                <option value="tree">ğŸ„ åœ£è¯æ ‘ (Christmas Tree)</option>
                <option value="fireworks">ğŸ† çƒŸèŠ± (Fireworks)</option>
            </select>
        </div>

        <div class="control-group">
            <label>ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#ff00cc">
        </div>

        <div class="control-group">
            <label>çŠ¶æ€: <span id="status-text">ç­‰å¾…åˆå§‹åŒ–...</span> <span id="status-dot" class="status-dot"></span></label>
            <div id="gesture-info">å¼ å¼€/æåˆæ‰‹æŒ‡æ§åˆ¶ç¼©æ”¾</div>
        </div>

        <button id="fullscreen-btn">å…¨å±æ¨¡å¼</button>
    </div>

    <!-- æ ¸å¿ƒä¿®æ”¹ï¼šå°† cdn.jsdelivr.net æ›¿æ¢ä¸ºå›½å†…æ›´å¿«çš„ npm.elemecdn.com -->
    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- é”™è¯¯å¤„ç† ---
        window.onerror = function(message, source, lineno, colno, error) {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.innerHTML = `<span style="color:#ff3333">âŒ åŠ è½½å¤±è´¥</span><br><span style="font-size:14px">${message}</span>`;
            }
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = [];
        let targetColors = [];
        let currentPositions = [];
        const particleCount = 15000;
        let currentShape = 'heart';
        let handScale = 1.0; 
        let baseColor = new THREE.Color(0xff00cc);
        let time = 0;

        // --- åˆå§‹åŒ– Three.js ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 100;
                colors[i] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // ä½¿ç”¨æœ¬åœ°ç”Ÿæˆçš„ Texture æˆ– Base64 é¿å…å›¾ç‰‡åŠ è½½è·¨åŸŸé—®é¢˜
            // è¿™é‡Œç»§ç»­ç”¨ Threejs å®˜ç½‘å›¾ï¼Œå¦‚æœè¿˜æ…¢å¯ä»¥æ¢ Base64
            const sprite = new THREE.TextureLoader().load('https://npm.elemecdn.com/three@0.128.0/examples/textures/sprites/disc.png');
            
            material = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            generateShape('heart');
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- å½¢çŠ¶ç”Ÿæˆé€»è¾‘ ---
        function generateShape(type) {
            currentShape = type;
            targetPositions = [];
            targetColors = [];
            
            const hexColor = document.getElementById('color-picker').value;
            const defaultColor = new THREE.Color(hexColor);

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                let r = defaultColor.r, g = defaultColor.g, b = defaultColor.b;

                if (type === 'heart') {
                    let valid = false;
                    let count = 0;
                    while (!valid && count < 100) {
                        let u = (Math.random() - 0.5) * 3;
                        let v = (Math.random() - 0.5) * 3;
                        let w = (Math.random() - 0.5) * 3;

                        let xx = u, yy = v, zz = w;
                        let a = xx*xx + 2.25*yy*yy + zz*zz - 1;
                        let val = a*a*a - (xx*xx*zz*zz*zz) - (0.1125*yy*yy*zz*zz*zz);
                        
                        if (val <= 0) {
                            valid = true;
                            const scale = 10;
                            x = u * scale;
                            y = w * scale; 
                            z = v * scale; 

                            const dist = Math.sqrt(x*x + y*y + z*z);
                            const normalizedDist = dist / 12;
                            r = 1.0; 
                            g = Math.max(0.4, 0.9 - normalizedDist * 0.6); 
                            b = Math.max(0.6, 0.95 - normalizedDist * 0.5); 
                            if (Math.random() > 0.96) { r = 1; g = 1; b = 1; }
                        }
                        count++;
                    }
                    if (!valid) { x=0; y=0; z=0; }
                } 
                else if (type === 'tree') {
                    if (i < particleCount * 0.05) {
                        x = (Math.random() - 0.5) * 1.5;
                        z = (Math.random() - 0.5) * 1.5;
                        y = (Math.random() * 4) - 12; 
                        r = 0.55; g = 0.27; b = 0.07;
                    } else {
                        const h = Math.random(); 
                        const angle = h * Math.PI * 15 + Math.random() * Math.PI * 2;
                        const maxR = 11 * (1 - h) + 0.5;
                        const rad = Math.sqrt(Math.random()) * maxR;
                        x = rad * Math.cos(angle);
                        z = rad * Math.sin(angle);
                        y = -8 + h * 22;
                        r = 0.0; g = 0.4 + Math.random() * 0.6; b = 0.1;
                        if (Math.random() < 0.15 && rad > maxR * 0.7) {
                            const ornament = Math.random();
                            if (ornament < 0.3) { r=1; g=0.1; b=0.1; } 
                            else if (ornament < 0.6) { r=1; g=0.84; b=0; } 
                            else { r=0.2; g=0.6; b=1; } 
                            x *= 1.05; z *= 1.05;
                        }
                        if (h > 0.98) {
                            r = 1; g = 1; b = 0.2;
                            x = (Math.random()-0.5) * 1.5;
                            z = (Math.random()-0.5) * 1.5;
                            y = 14 + Math.random() * 2;
                        }
                    }
                }
                else if (type === 'fireworks') {
                    const rad = 20 * Math.cbrt(Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                    r = Math.random(); g = Math.random(); b = Math.random();
                }

                targetPositions.push({x, y, z});
                targetColors.push({r, g, b});
            }
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            particles.rotation.y += 0.002;

            for (let i = 0; i < particleCount; i++) {
                const target = targetPositions[i];
                const targetCol = targetColors[i];
                const idx = i * 3;
                let tx = target.x, ty = target.y, tz = target.z;
                
                const scale = Math.max(0.1, Math.min(3.0, handScale));
                tx *= scale; ty *= scale; tz *= scale;

                if (currentShape === 'fireworks') {
                    tx += Math.sin(time + i) * 0.5;
                    ty += Math.cos(time + i) * 0.5;
                } else {
                    tx += Math.sin(time * 2 + i) * 0.1;
                    ty += Math.cos(time * 3 + i) * 0.1;
                }

                positions[idx] += (tx - positions[idx]) * 0.1;
                positions[idx + 1] += (ty - positions[idx + 1]) * 0.1;
                positions[idx + 2] += (tz - positions[idx + 2]) * 0.1;

                if (targetCol) {
                    colors[idx] += (targetCol.r - colors[idx]) * 0.1;
                    colors[idx + 1] += (targetCol.g - colors[idx + 1]) * 0.1;
                    colors[idx + 2] += (targetCol.b - colors[idx + 2]) * 0.1;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);

            const dateEl = document.getElementById('heart-date');
            if (currentShape === 'heart') {
                let opacity = 0;
                if (handScale > 1.2) opacity = Math.min(1, (handScale - 1.2) / 0.5);
                dateEl.style.opacity = opacity;
                dateEl.style.transform = `translate(-50%, -50%) scale(${0.8 + opacity * 0.4})`;
            } else {
                dateEl.style.opacity = 0;
            }

            const fireworksEl = document.getElementById('fireworks-text');
            if (currentShape === 'fireworks') {
                let opacity = 0;
                if (handScale > 1.2) opacity = Math.min(1, (handScale - 1.2) / 0.5);
                fireworksEl.style.opacity = opacity;
                fireworksEl.style.transform = `translate(-50%, -50%) scale(${0.8 + opacity * 0.4})`;
            } else {
                fireworksEl.style.opacity = 0;
            }
        }

        // --- MediaPipe Hands é›†æˆ ---
        function onResults(results) {
            const loading = document.getElementById('loading');
            if (loading) loading.style.display = 'none';

            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('status-active');
                statusText.innerText = "å·²æ£€æµ‹åˆ°æ‰‹åŠ¿";
                
                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                const targetScale = mapRange(distance, 0.02, 0.25, 0.3, 2.5);
                handScale += (targetScale - handScale) * 0.1;

            } else {
                statusDot.classList.remove('status-active');
                statusText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                handScale += (1.0 - handScale) * 0.05;
            }
        }

        function mapRange(value, inMin, inMax, outMin, outMax) {
            return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
        }

        // --- åˆå§‹åŒ– (å«å®¹é”™å¤„ç†) ---
        window.onload = function() {
            try {
                if (typeof THREE === 'undefined') throw new Error("Three.js åŠ è½½å¤±è´¥");
                initThree();
                animate();

                // UI äº‹ä»¶
                document.getElementById('shape-select').addEventListener('change', (e) => generateShape(e.target.value));
                document.getElementById('color-picker').addEventListener('input', (e) => material.color.set(e.target.value));
                document.getElementById('fullscreen-btn').addEventListener('click', () => {
                    if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                    else if (document.exitFullscreen) document.exitFullscreen();
                });

                // æ£€æŸ¥ MediaPipe åº“
                if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                    throw new Error("MediaPipe åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ");
                }

                // å¯åŠ¨æ‘„åƒå¤´
                const videoElement = document.getElementById('video-preview');
                const loading = document.getElementById('loading');
                const statusText = document.getElementById('status-text');

                // æ ¸å¿ƒä¿®æ”¹ï¼šlocateFile ä¹Ÿå¿…é¡»æŒ‡å‘å›½å†…é•œåƒ
                const hands = new Hands({locateFile: (file) => {
                    return `https://npm.elemecdn.com/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);

                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 320,
                    height: 240
                });
                
                statusText.innerText = "æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´...";
                
                cameraUtils.start()
                    .then(() => {
                        console.log("Camera started");
                        if(loading) loading.innerHTML = "åŠ è½½å®Œæˆ!<br><span style='font-size:16px'>è¯·åœ¨å³ä¸Šè§’å°è¯•æ‰‹åŠ¿äº’åŠ¨</span>";
                        setTimeout(() => { if(loading) loading.style.display = 'none'; }, 2000);
                    })
                    .catch(err => {
                        console.error("Camera error:", err);
                        statusText.innerText = "æ‘„åƒå¤´å¤±è´¥";
                        alert("æ— æ³•å¯åŠ¨æ‘„åƒå¤´: " + err.message + "\nè¯·ç¡®ä¿ç‚¹å‡»äº†'å…è®¸'ä½¿ç”¨æ‘„åƒå¤´ã€‚");
                    });

            } catch (e) {
                console.error(e);
                const loading = document.getElementById('loading');
                if(loading) loading.innerHTML = `<span style="color:red">âŒ åˆå§‹åŒ–é”™è¯¯</span><br>${e.message}`;
            }
        };
    </script>
</body>
</html>